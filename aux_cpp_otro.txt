#include "../Comportamientos_Jugador/jugador.hpp"
#include <iostream>
using namespace std;
//Muestra información
void ComportamientoJugador::MuestraInformacion(Sensores sensores){
	cout << "Posicion: fila " << sensores.posF << " columna " << sensores.posC << " ";
	switch(sensores.sentido){
		case 0: cout << "Norte" << endl; break;
		case 1: cout << "Noreste" << endl; break;
		case 2: cout << "Este" << endl; break;
		case 3: cout << "Sureste" << endl; break;
		case 4: cout << "Sur " << endl; break;
		case 5: cout << "Suroeste" << endl; break;
		case 6: cout << "Oeste" << endl; break;
		case 7: cout << "Noroeste" << endl; break;
	}
	cout << "Terreno: ";
	for (int i=0; i<sensores.terreno.size(); i++)
		cout << sensores.terreno[i];
		cout << endl;
		cout << "Superficie: ";
	for (int i=0; i<sensores.superficie.size(); i++)
		cout << sensores.superficie[i];
		cout << endl;
		cout << "Colisión: " << sensores.colision << endl;
		cout << "Reset: " << sensores.reset << endl;
		cout << "Vida: " << sensores.vida << endl;
		cout << endl;
	}
//determina la orientacion según la ultima accion
void ComportamientoJugador::DeterminarEfectoUltimaAccion(){
	int a;
	switch (last_action){
		case actFORWARD: //si se ha avanzado se actualiza las filas y columnas
		if(bien_situado){
			switch (current_state.brujula){
			case norte: current_state.fil--; break;
			case noreste: current_state.fil--;
				current_state.col++; break;
			case este: current_state.col++; break;
			case sureste: current_state.fil++;
				current_state.col++; break;
			case sur: current_state.fil++; break;
			case suroeste: current_state.fil++;
				current_state.col--; break;
			case oeste: current_state.col--; break;
			case noroeste:
				current_state.fil--;current_state.col--; break;
			}
		}
		break;
		//si se ha girado se determina la nueva orientación
		case actTURN_SL:
			a = current_state.brujula;
			a = (a+7)%8;
			current_state.brujula = static_cast<Orientacion>(a);
			break;
		case actTURN_SR:
			a = current_state.brujula;
			a = (a+1)%8;
			current_state.brujula = static_cast<Orientacion>(a);
			break;
		case actTURN_BL:
			a = current_state.brujula;
			a = (a+5)%8;
			current_state.brujula = static_cast<Orientacion>(a);
			break;
		case actTURN_BR:
			a = current_state.brujula;
			a = (a+3)%8;
			current_state.brujula = static_cast<Orientacion>(a);
		break;
	}
}
//orientarse por si tenemos sensores o estamos situados en una casilla de posicionamiento
void ComportamientoJugador::Orientarse(Sensores sensores){
	current_state.fil = sensores.posF;
	current_state.col= sensores.posC;
	current_state.brujula = sensores.sentido;
	bien_situado = true;
}
//actualizamos el terreno descubierto
void ComportamientoJugador::PonerTerrenoEnMatriz(const vector<unsigned char> & terreno,const state & st,vector< vector<unsigned char> > & matriz){
	matriz[st.fil][st.col] = terreno[0];//siempre es la misma para todas las direcciones
	//se podrían buscar algoritmos para rellenar el mapa de forma más corta, pero como no es el
	//objetivo de la práctica y requiere myucho tiempo opto por hacerlo a mano. Si el sensor fuera una
	//matriz sería más sencillo
	switch (st.brujula){
		case norte:
			matriz[st.fil - 1][st.col - 1] = terreno[1];
			matriz[st.fil - 1][st.col] = terreno[2];
			matriz[st.fil - 1][st.col + 1] = terreno[3];
			matriz[st.fil - 2][st.col - 2] = terreno[4];
			matriz[st.fil - 2][st.col - 1] = terreno[5];
			matriz[st.fil - 2][st.col] = terreno[6];
			matriz[st.fil - 2][st.col + 1] = terreno[7];
			matriz[st.fil - 2][st.col + 2] = terreno[8];
			matriz[st.fil - 3][st.col - 3] = terreno[9];
			matriz[st.fil - 3][st.col - 2] = terreno[10];
			matriz[st.fil - 3][st.col - 1] = terreno[11];
			matriz[st.fil - 3][st.col] = terreno[12];
			matriz[st.fil - 3][st.col + 1] = terreno[13];
			matriz[st.fil - 3][st.col + 2] =t erreno[14];
			matriz[st.fil - 3][st.col + 3] = terreno[15];
			break;
		case sur:
			matriz[st.fil + 1][st.col + 1] =terreno[1];
			matriz[st.fil + 1][st.col] = terreno[2];
			matriz[st.fil + 1][st.col - 1] =terreno[3];
			matriz[st.fil + 2][st.col + 2] =terreno[4];
			matriz[st.fil + 2][st.col + 1] =terreno[5];
			matriz[st.fil + 2][st.col] = terreno[6];
			matriz[st.fil + 2][st.col - 1] =terreno[7];
			matriz[st.fil + 2][st.col - 2] =terreno[8];
			matriz[st.fil + 3][st.col + 3] =terreno[9];
			matriz[st.fil + 3][st.col + 2] =terreno[10];
			matriz[st.fil + 3][st.col + 1] =terreno[11];
			matriz[st.fil + 3][st.col] = terreno[12];
			matriz[st.fil + 3][st.col - 1] =terreno[13];
			matriz[st.fil + 3][st.col - 2] =terreno[14];
			matriz[st.fil + 3][st.col - 3] =terreno[15];
			break;
		case este:
			matriz[st.fil - 1][st.col + 1] =terreno[1];
			matriz[st.fil][st.col + 1] = terreno[2];
			matriz[st.fil + 1][st.col + 1] =terreno[3];
			matriz[st.fil - 2][st.col + 2] =terreno[4];
			matriz[st.fil - 1][st.col + 2] =terreno[5];
			matriz[st.fil][st.col + 2] = terreno[6];
			matriz[st.fil + 1][st.col + 2] =terreno[7];
			matriz[st.fil + 2][st.col + 2] =terreno[8];
			matriz[st.fil - 3][st.col + 3] =terreno[9];
			matriz[st.fil - 2][st.col + 3] =terreno[10];
			matriz[st.fil - 1][st.col + 3] =terreno[11];
			matriz[st.fil][st.col + 3] = terreno[12];
			matriz[st.fil + 1][st.col + 3] =terreno[13];
			matriz[st.fil + 2][st.col + 3] =terreno[14];
			matriz[st.fil + 3][st.col + 3] =terreno[15];
			break;
		case oeste:
			matriz[st.fil + 1][st.col - 1] =terreno[1];
			matriz[st.fil][st.col -1 ] = terreno[2];
			matriz[st.fil - 1][st.col - 1] =terreno[3];
			matriz[st.fil + 2][st.col - 2] =terreno[4];
			matriz[st.fil + 1][st.col - 2] =terreno[5];
			matriz[st.fil][st.col - 2] = terreno[6];
			matriz[st.fil - 1][st.col - 2] =terreno[7];
			matriz[st.fil - 2][st.col - 2] =terreno[8];
			matriz[st.fil + 3][st.col - 3] =terreno[9];
			matriz[st.fil + 2][st.col - 3] =terreno[10];
			matriz[st.fil + 1][st.col - 3] =terreno[11];
			matriz[st.fil][st.col - 3] = terreno[12];
			matriz[st.fil - 1][st.col - 3] =terreno[13];
			matriz[st.fil - 2][st.col - 3] =terreno[14];
			matriz[st.fil - 3][st.col - 3] =terreno[15];
			break;
		case noreste:
			matriz[st.fil - 1][st.col] = terreno[1];
			matriz[st.fil - 1][st.col + 1] =terreno[2];
			matriz[st.fil][st.col + 1] = terreno[3];
			matriz[st.fil - 2][st.col] = terreno[4];
			matriz[st.fil - 2][st.col + 1] =terreno[5];
			matriz[st.fil - 2][st.col + 2] =terreno[6];
			matriz[st.fil - 1][st.col + 2] =terreno[7];
			matriz[st.fil][st.col + 2] = terreno[8];
			matriz[st.fil - 3][st.col] = terreno[9];
			matriz[st.fil - 3][st.col + 1] =terreno[10];
			matriz[st.fil - 3][st.col + 2] =terreno[11];
			matriz[st.fil - 3][st.col + 3] =terreno[12];
			matriz[st.fil - 2][st.col + 3] = terreno[13];
			matriz[st.fil - 1][st.col + 3] = terreno[14];
			matriz[st.fil][st.col + 3] = terreno[15];
			break;
		case noroeste:
			matriz[st.fil][st.col - 1] = terreno[1];
			matriz[st.fil - 1][st.col - 1] =terreno[2];
			matriz[st.fil - 1][st.col] = terreno[3];
			matriz[st.fil][st.col - 2] = terreno[4];
			matriz[st.fil - 1][st.col - 2] =terreno[5];
			matriz[st.fil - 2][st.col - 2] =terreno[6];
			matriz[st.fil - 2][st.col - 1] =terreno[7];
			matriz[st.fil - 2][st.col] = terreno[8];
			matriz[st.fil][st.col - 3] = terreno[9];
			matriz[st.fil - 1][st.col - 3] =terreno[10];
			matriz[st.fil - 2][st.col - 3] =terreno[11];
			matriz[st.fil - 3][st.col - 3] =terreno[12];
			matriz[st.fil - 3][st.col - 2] =terreno[13];
			matriz[st.fil - 3][st.col - 1] =terreno[14];
			matriz[st.fil - 3][st.col] = terreno[15];
			break;
		case sureste:
			matriz[st.fil][st.col + 1] = terreno[1];
			matriz[st.fil + 1][st.col + 1] =terreno[2];
			matriz[st.fil + 1][st.col] = terreno[3];
			matriz[st.fil][st.col + 2] = terreno[4];
			matriz[st.fil + 1][st.col + 2] =terreno[5];
			matriz[st.fil + 2][st.col + 2] =terreno[6];
			matriz[st.fil + 2][st.col + 1] =terreno[7];
			matriz[st.fil + 2][st.col] = terreno[8];
			matriz[st.fil][st.col + 3] = terreno[9];
			matriz[st.fil + 1][st.col + 3] =terterreno[11];
			matriz[st.fil + 3][st.col + 3] =terreno[12];
			matriz[st.fil + 3][st.col + 2] =terreno[13];
			matriz[st.fil + 3][st.col + 1] =terreno[14];
			matriz[st.fil + 3][st.col] = terreno[15];
			break;
		case suroeste:
			matriz[st.fil + 1][st.col] = terreno[1];
			matriz[st.fil + 1][st.col - 1] =terreno[2];
			matriz[st.fil][st.col - 1] = terreno[3];
			matriz[st.fil + 2][st.col] = terreno[4];
			matriz[st.fil + 2][st.col - 1] =terreno[5];
			matriz[st.fil + 2][st.col - 2] =terreno[6];
			matriz[st.fil + 1][st.col - 2] =terreno[7];
			matriz[st.fil][st.col - 2] = terreno[8];
			matriz[st.fil + 3][st.col] = terreno[9];
			matriz[st.fil + 3][st.col - 1] =terreno[10];
			matriz[st.fil + 3][st.col - 2] =terreno[11];
			matriz[st.fil + 3][st.col - 3] =terreno[12];
			matriz[st.fil + 2][st.col - 3] =terreno[13];
			matriz[st.fil + 1][st.col - 3] =terreno[14];
			matriz[st.fil][st.col - 3] = terreno[15];
			break;
	}
}
//se busca una casilla para satisfacer necesidades del agente según su estado y lo que ve, devuelve la acción que se
//debería hacer
Action ComportamientoJugador::BuscarCasilla(Sensores sensores){
	Action accion = actIDLE; //accion a devolver, si no se encuentra nada se queda quieto y buscará hacer otra cosa
	int pos = -1; //posición por si encontramos algo
	bool encontrado = false; //para saber que hemos encontrado algo
	bool lobo = false; //por si hay un lobo, ya que la accion sera contraria a las demas
	bool dejarDeCargar = (sensores.vida < vidaBaja) && ((sensores.vida * factorVidaBateria) < sensores.bateria ); //si quedan pocos ciclos y
	//tenemos 4 veces más de batería que de ciclos
	//no recargamos
	//máxima prioridad recargar si estamos a niveles críticos
	if( (sensores.bateria < bateria_muy_baja) && !dejarDeCargar)
	for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
		if(sensores.terreno[i] == 'X'){
			encontrado = true;
			pos = i;
		}
	//lo siguiente sería el biquini, ya que el agua gasta mucha batería
	if(!bikini && !encontrado)
		for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
			if(sensores.terreno[i] == 'K'){
				encontrado = true;
				pos = i;
			}
	//lo siguiente son las zapas, que el bosque tambien gasta una cantidad considerable de batería
	if(!zapatillas && !encontrado)
		for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
			if(sensores.terreno[i] == 'D'){
				encontrado = true;
				pos = i;
			}
	//lo siguiente sería posicionarse
	if(!bien_situado && !encontrado)
		for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
			if(sensores.terreno[i] == 'G'){
				encontrado = true;
				pos = i;
			}
	//después batería baja
	if( (sensores.bateria < bateria_baja) && !encontrado && !dejarDeCargar )
		for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
			if(sensores.terreno[i] == 'X'){
				encontrado = true;
				pos = i;
			}
	//si estamos en agua o bosque sin sus items buscar una casilla que gaste menos
	if( ( (!bikini && sensores.terreno[0] == 'A') || (!zapatillas && sensores.terreno[0] == 'B' ) ) && !encontrado)
		for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
			if(sensores.terreno[i] == 'S' || sensores.terreno[i] == 'T'){
				encontrado = true;
				pos = i;
			}
	//por último, si estamos ubicados y tenemos batería esquivamos a los lobos
	if(bien_situado && (sensores.bateria > bateria_baja)){
		for(int i = 1; i < sensores.terreno.size() && !encontrado; i++)
			if(sensores.superficie[i] == 'l'){
				encontrado = true;
				pos = i;
				lobo = true;
			}
	}
	//si hemos encontrado algo determinamos la acción
	if(encontrado){
		if( (pos == 2 ) || (pos == 6) || (pos == 12) || (pos == 5) || (pos == 7) || (pos == 10) || (pos == 11) || (pos == 13) || (pos == 14)){
			if(lobo){//si hay lobo giramos aleatoriamente
				if(girar_derecha){
					accion = accion = actTURN_BR;
				}
				else{
					accion = accion = actTURN_BL;
				}
			}// si es otra cosa avanzamos
			else
				accion = actFORWARD;
		}
		else if( (pos == 3 ) || (pos == 8) || (pos == 15) ){
			//por la derecha
			if(lobo)//si hay lobo vamos a la izquierda
				accion = accion = actTURN_BL;
			else//si no hay nos orientamos al objeto
				accion = actTURN_SR;
		}
		else if( (pos == 1 ) || (pos == 4) || (pos == 9) ){
			//casa similar al anterior, pero por la izquierda
			if(lobo)
				accion = actTURN_BR;
			else
				accion = actTURN_SL;
		}
	}
	return accion;
}
Action ComportamientoJugador::DecidirAccion(Sensores sensores){
	Action accion = actIDLE; //estar quieto por defecto
	bool condicionAvanzar = sensores.terreno[2]=='T' or sensores.terreno[2]=='S'; //condición basica para avanzar,
	//si se tiene algun item o estamos en una
	//casilla que gasta mucho se modifica
	//esta condición se tiene que dar siempre para avanzar
	bool condicionElemental = (sensores.superficie[2]=='_') && (!sensores.colision) && (sensores.terreno[2]!='P') && (sensores.terreno[2]!='M');
	bool dejarDeCargar = (sensores.vida < vidaBaja) && ((sensores.vida * factorVidaBateria) < (sensores.bateria));//igual que en buscar casilla
	//si estamos sobre una casilla de recarga y tenemos poco batería recargamos
	if( (sensores.terreno[0] == 'X') && (sensores.bateria < bateria_baja) && !dejarDeCargar )
		recargando = true;
	if(recargando){
		accion = actIDLE;
		if ( (sensores.bateria + 10) > (bateriaRecarga) || dejarDeCargar)
			recargando = false;
		return accion;
	}
	//buscamos si podemos hacer una acción que nos beneficie
	accion = BuscarCasilla(sensores);
	if(accion != actIDLE){//si se ha encontrado algo
		if(accion == actFORWARD){//si se va avanzar hay que superar la condición básica
			if(condicionElemental){
				return accion;
			}
		}else{//girar siempre se puede
			return accion;
		}
	}
	if(current_state.brujula % 2 == 0 && bien_situado){//para entrar y salir facilmente de los muros de paradise
		if(sensores.terreno[1] != 'M' && sensores.terreno[5] =='M'){//por si esta a la izquierda
			accion = actTURN_SL;
			return accion;
		}
		if(sensores.terreno[3] != 'M' && sensores.terreno[7] == 'M'){//por si esta a la derecha
			accion = actTURN_SR;
			return accion;
		}
	}
	if(current_state.brujula % 2 == 0 && bien_situado){//para poder pasar por el colorado canyon
		if(sensores.terreno[1] != 'P' && sensores.terreno[5] == 'P' && sensores.terreno[7] !='P'){//por si está a la izquierda
			accion = actTURN_SL;
			return accion;
		}
		if(sensores.terreno[3] != 'P' && sensores.terreno[7] == 'P' && sensores.terreno[7] !='P' ){//por si está a la izquierda
			accion = actTURN_SR;
			return accion;
		}
	}
	if(sensores.bateria > (bateria_muy_baja / 1.5)){//si tenemos sufiencte batería y los items actualizamos la opción de avanzar
		if(bikini)
			condicionAvanzar = condicionAvanzar ||
			sensores.terreno[2]=='A';
	}
	if(sensores.bateria > (bateria_muy_baja / 1.4) ){//si tenemos sufiencte batería y los items actualizamos la opción de avanzar
		if(zapatillas)
			condicionAvanzar = condicionAvanzar || sensores.terreno[2]=='B';
	}
	//por si estamos en una casilla de la que queremos pasar y no
	//podemos, hay que salir de ella sí o sí
	if((sensores.terreno[0]=='A') )
		condicionAvanzar = condicionAvanzar || sensores.terreno[2]=='A';
	if((sensores.terreno[0]=='B'))
		condicionAvanzar = condicionAvanzar || sensores.terreno[2]=='B';
	if( (sensores.terreno[0]=='G' || sensores.terreno[0]=='K' || sensores.terreno[0]=='D' || sensores.terreno[0]=='X') || numGiros > 50)//si hemos girado demasiado seguramente
	//estaremos en una isla o en un claro de un bosque sin los
	//items
		condicionAvanzar = condicionAvanzar || sensores.terreno[2]=='B' || sensores.terreno[2]=='A';
	if (condicionAvanzar && condicionElemental){//si se puede
		//avanzar se avanza
		accion = actFORWARD;
		if(numGiros >= 0)
			numGiros--; //si hemos avanzado reducimos los numeros
		//de giros porque es menos probable que estemos atrapados
		//en una isla
	}
	else{//si no se puede giramos según lo que valgan la variables
	//y la actualizamos.
		if(girar_derecha){
			if(girar_45_grados)
					accion = actTURN_SR;
				else
					accion = actTURN_BR;
		}
		else{
			if(girar_45_grados)
				accion = actTURN_SL;
			else
				accion = actTURN_BL;
		}
		girar_derecha = (rand()%2 ==0);
		girar_45_grados = (rand()%2 ==0);
		numGiros++;//aumentamos el número de giros, es más
		//probable que estemos en una isla
	}
	return accion;
}
Action ComportamientoJugador::think(Sensores sensores){
	//quedarse quieto por defecto
	Action accion = actIDLE;
	//por si nos han matado
	if(sensores.reset){
		bien_situado = false;
		bikini = false;
		zapatillas = false;
		recargando = false;
		current_state.brujula = norte; //siempre que reaparecemos es con orientación norte
	}
	//mostrar información
	MuestraInformacion(sensores);
	// Determinar el efecto de la ultima accion enviada
	if(!sensores.colision)
		DeterminarEfectoUltimaAccion();
		//Orientarse si no estamos situados, teniendo en cuenta si nos funciona o no el sensor
	if ( !bien_situado and ( sensores.terreno[0]=='G' or sensores.posC != -1) )
		Orientarse(sensores);
	//Actualizar mapa si procede
	if (bien_situado){
		PonerTerrenoEnMatriz(sensores.terreno,current_state,mapaResultado);
	}
	//actualizar si hemos conseguido bikini o zapatillas
	if(sensores.terreno[0] == 'K')
		bikini = true;
	if(sensores.terreno[0] == 'D')
		zapatillas = true;
	//decidir acción
	accion = DecidirAccion(sensores);
	//recordar la ultima accion
	last_action = accion;
	return accion;
}
int ComportamientoJugador::interact(Action accion, int valor){
	return false;
}


